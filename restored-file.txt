{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "b2583db5",
   "metadata": {},
   "source": [
    "# F1 Race Predictor with Historical Data, Agent-Based Modeling, and Monte Carlo Simulation"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6ef5b941",
   "metadata": {},
   "source": [
    "## 1. Introduction\n",
    "\n",
    "In this notebook, we aim to build an F1 Race Predictor that provides real-time, lap-by-lap predictions for upcoming races, incorporating historical data, driver and constructor reliability, and simulating uncertainties using Monte Carlo simulations. We will utilize data up to the race start to train our models, create driver agents based on historical performance, and simulate race outcomes."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8f6de298",
   "metadata": {},
   "source": [
    "## 2. Data Collection and Integration"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ce1ba3cc",
   "metadata": {},
   "source": [
    "### 2.1 Import Necessary Libraries"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "1c5e4c82",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from datetime import datetime\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.preprocessing import StandardScaler, OneHotEncoder\n",
    "from sklearn.compose import ColumnTransformer\n",
    "from sklearn.pipeline import Pipeline\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.metrics import mean_absolute_error\n",
    "import joblib\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "%matplotlib inline\n",
    "\n",
    "# For Monte Carlo Simulation and Agent-Based Modeling\n",
    "import random\n",
    "from tqdm import tqdm\n",
    "\n",
    "# For Animation\n",
    "import matplotlib.animation as animation\n",
    "from matplotlib.animation import FuncAnimation"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6d3a08af",
   "metadata": {},
   "source": [
    "### 2.2 Load Data with Proper Handling of Missing Values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "c8531f11",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define NA values\n",
    "na_values = ['\\\\N']\n",
    "\n",
    "# **Circuits**\n",
    "circuits = pd.read_csv('circuits.csv', na_values=na_values)\n",
    "print(f'Circuits: {circuits.shape}')\n",
    "\n",
    "# **Constructors**\n",
    "constructors = pd.read_csv('constructors.csv', na_values=na_values)\n",
    "print(f'Constructors: {constructors.shape}')\n",
    "\n",
    "# **Drivers**\n",
    "drivers = pd.read_csv('drivers.csv', na_values=na_values)\n",
    "print(f'Drivers: {drivers.shape}')\n",
    "\n",
    "# **Races**\n",
    "races = pd.read_csv('races.csv', na_values=na_values)\n",
    "print(f'Races: {races.shape}')\n",
    "\n",
    "# **Results**\n",
    "results = pd.read_csv('results.csv', na_values=na_values)\n",
    "print(f'Results: {results.shape}')\n",
    "\n",
    "# **Lap Times**\n",
    "lap_times = pd.read_csv('lap_times.csv', na_values=na_values)\n",
    "print(f'Lap Times: {lap_times.shape}')\n",
    "\n",
    "# **Pit Stops**\n",
    "pit_stops = pd.read_csv('pit_stops.csv', na_values=na_values)\n",
    "print(f'Pit Stops: {pit_stops.shape}')\n",
    "\n",
    "# **Qualifying**\n",
    "qualifying = pd.read_csv('qualifying.csv', na_values=na_values)\n",
    "print(f'Qualifying: {qualifying.shape}')\n",
    "\n",
    "# **Status**\n",
    "status = pd.read_csv('status.csv', na_values=na_values)\n",
    "print(f'Status: {status.shape}')\n",
    "\n",
    "# **Weather Data (Placeholder)**\n",
    "# Since actual weather data is not available, we'll create placeholder data.\n",
    "weather = pd.DataFrame()\n",
    "\n",
    "# **Practice Sessions Data (Placeholder)**\n",
    "# Since actual practice session data is not available, we'll create placeholder data.\n",
    "practice_sessions = pd.DataFrame()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7c09edb8",
   "metadata": {},
   "source": [
    "## 3. Data Preprocessing and Feature Engineering"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0f0ae3e1",
   "metadata": {},
   "source": [
    "### 3.1 Merge DataFrames to Create a Unified Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "f6c69b4d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **Merge Results with Races**\n",
    "results = results.merge(races[['raceId', 'year', 'round', 'circuitId', 'name', 'date']], on='raceId', how='left')\n",
    "\n",
    "# **Merge with Drivers**\n",
    "drivers['dob'] = pd.to_datetime(drivers['dob'], errors='coerce')\n",
    "results = results.merge(drivers[['driverId', 'driverRef', 'forename', 'surname', 'dob', 'nationality']], on='driverId', how='left')\n",
    "\n",
    "# **Merge with Constructors**\n",
    "results = results.merge(constructors[['constructorId', 'name', 'nationality']], on='constructorId', how='left', suffixes=('_driver', '_constructor'))\n",
    "\n",
    "# **Merge with Circuits**\n",
    "results = results.merge(circuits[['circuitId', 'name', 'location', 'country', 'lat', 'lng', 'alt']], on='circuitId', how='left', suffixes=('', '_circuit'))\n",
    "\n",
    "# **Merge with Status**\n",
    "results = results.merge(status, on='statusId', how='left')\n",
    "\n",
    "# **Preview the Merged Data**\n",
    "print(f'Merged Results: {results.shape}')\n",
    "results.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "001dbfa8",
   "metadata": {},
   "source": [
    "### 3.2 Convert Data Types and Handle Missing Values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "6cb8d365",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **Convert Date Columns to Datetime**\n",
    "results['date'] = pd.to_datetime(results['date'], errors='coerce')\n",
    "results['dob'] = pd.to_datetime(results['dob'], errors='coerce')\n",
    "\n",
    "# **Handle Missing Values in 'position'**\n",
    "unique_positions = results['position'].unique()\n",
    "print(f'Unique values in position before handling: {unique_positions}')\n",
    "\n",
    "# Convert 'position' to numeric, coercing errors to NaN\n",
    "results['position'] = pd.to_numeric(results['position'], errors='coerce')\n",
    "\n",
    "# Fill NaN values with 99 and convert to integer\n",
    "results['position'] = results['position'].fillna(99).astype(int)\n",
    "\n",
    "# **Convert Time Columns to Total Seconds**\n",
    "def time_to_seconds(time_str):\n",
    "    if pd.isnull(time_str):\n",
    "        return np.nan\n",
    "    if isinstance(time_str, str) and ':' in time_str:\n",
    "        mins, secs = time_str.split(':')\n",
    "        return int(mins) * 60 + float(secs)\n",
    "    elif isinstance(time_str, (int, float)):\n",
    "        return float(time_str)\n",
    "    else:\n",
    "        return np.nan\n",
    "\n",
    "results['fastestLapTime_seconds'] = results['fastestLapTime'].apply(time_to_seconds)\n",
    "\n",
    "# **Handle Missing Lap Times**\n",
    "lap_times['milliseconds'] = lap_times['milliseconds'].fillna(lap_times['milliseconds'].mean())"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b3c32bfe",
   "metadata": {},
   "source": [
    "### 3.3 Calculate Reliability Metrics"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "a3538fcd",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **Classify Status Codes into Driver and Constructor Related**\n",
    "\n",
    "# Driver-Related Status IDs\n",
    "driver_related_status_ids = [\n",
    "    2,11,12,13,14,15,16,17,18,19,21,28,34,35,40,43,44,48,50,53,54,55,56,58,59,60,61,62,\n",
    "    65,66,67,68,69,71,73,74,75,77,81,82,84,85,86,87,88,89,90,94,95,96,97,98,99,100,101,\n",
    "    103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,123,124,\n",
    "    125,127,130,131,132,133,134,135,136,138,139,141\n",
    "]\n",
    "\n",
    "# Constructor-Related Status IDs\n",
    "constructor_related_status_ids = [\n",
    "    1,3,4,5,6,7,8,9,10,20,22,23,24,25,26,27,29,30,31,32,33,37,38,39,41,42,46,47,49,51,\n",
    "    128,129,130,131,132,133,134,135,136,137,138,140,141\n",
    "]\n",
    "\n",
    "# **Calculate Driver Reliability**\n",
    "driver_status = results[['driverId', 'statusId']]\n",
    "driver_status['driver_issue'] = driver_status['statusId'].isin(driver_related_status_ids)\n",
    "driver_reliability = driver_status.groupby('driverId')['driver_issue'].apply(lambda x: 1 - x.mean()).reset_index()\n",
    "driver_reliability.rename(columns={'driver_issue': 'driver_reliability'}, inplace=True)\n",
    "\n",
    "# **Calculate Constructor Reliability**\n",
    "constructor_status = results[['constructorId', 'statusId']]\n",
    "constructor_status['constructor_issue'] = constructor_status['statusId'].isin(constructor_related_status_ids)\n",
    "constructor_reliability = constructor_status.groupby('constructorId')['constructor_issue'].apply(lambda x: 1 - x.mean()).reset_index()\n",
    "constructor_reliability.rename(columns={'constructor_issue': 'constructor_reliability'}, inplace=True)\n",
    "\n",
    "# **Merge Reliability Metrics with Results**\n",
    "results = results.merge(driver_reliability, on='driverId', how='left')\n",
    "results = results.merge(constructor_reliability, on='constructorId', how='left')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "99b565cc",
   "metadata": {},
   "source": [
    "### 3.4 Feature Engineering"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "dcbf5b49",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **Calculate Driver Age at the Time of Race**\n",
    "results = results.dropna(subset=['date', 'dob'])\n",
    "results['driver_age'] = (results['date'] - results['dob']).dt.days / 365.25\n",
    "\n",
    "# **Calculate Total Points Up to Each Race**\n",
    "results = results.sort_values(['driverId', 'year', 'round'])\n",
    "results['cumulative_points'] = results.groupby('driverId')['points'].cumsum()\n",
    "\n",
    "# **Average Finishing Position**\n",
    "driver_performance = results.groupby('driverId')['positionOrder'].mean().reset_index()\n",
    "driver_performance.rename(columns={'positionOrder': 'avg_finish_position'}, inplace=True)\n",
    "\n",
    "# **Merge Driver Performance with Results**\n",
    "results = results.merge(driver_performance, on='driverId', how='left')\n",
    "\n",
    "# **Average Lap Time per Driver per Race**\n",
    "# Note: Lap times are only available from 2011 onwards\n",
    "lap_times['race_year'] = lap_times['raceId'].map(races.set_index('raceId')['year'])\n",
    "lap_times = lap_times[lap_times['race_year'] >= 2011]\n",
    "\n",
    "avg_lap_times = lap_times.groupby(['driverId'])['milliseconds'].mean().reset_index()\n",
    "avg_lap_times.rename(columns={'milliseconds': 'avg_lap_time_ms'}, inplace=True)\n",
    "\n",
    "# **Merge Average Lap Times with Results**\n",
    "results = results.merge(avg_lap_times, on='driverId', how='left')\n",
    "\n",
    "# **Handle Missing Lap Times**\n",
    "results['avg_lap_time_ms'] = results['avg_lap_time_ms'].fillna(results['avg_lap_time_ms'].mean())\n",
    "\n",
    "# **Qualifying Position**\n",
    "qualifying_positions = qualifying.groupby('driverId')['position'].mean().reset_index()\n",
    "qualifying_positions.rename(columns={'position': 'avg_qualifying_position'}, inplace=True)\n",
    "\n",
    "# **Merge Qualifying Positions with Results**\n",
    "results = results.merge(qualifying_positions, on='driverId', how='left')\n",
    "\n",
    "# **Handle Missing Qualifying Positions**\n",
    "results['avg_qualifying_position'] = results['avg_qualifying_position'].fillna(results['avg_qualifying_position'].mean())"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "40c46e36",
   "metadata": {},
   "source": [
    "### 3.5 Prepare Final Feature Set"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "bd5234b6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **Select Features for Modeling**\n",
    "feature_columns = [\n",
    "    'driver_age', 'cumulative_points', 'avg_finish_position', 'avg_lap_time_ms',\n",
    "    'avg_qualifying_position', 'driver_reliability', 'constructor_reliability',\n",
    "    'nationality_driver', 'name_constructor', 'country'\n",
    "]\n",
    "\n",
    "# **Target Variable**\n",
    "target_column = 'positionOrder'\n",
    "\n",
    "# **Prepare Feature Matrix and Target Vector**\n",
    "X = results[feature_columns]\n",
    "y = results[target_column]\n",
    "\n",
    "# **Handle Missing Values in Features**\n",
    "X = X.fillna(0)\n",
    "\n",
    "# **Define Numerical and Categorical Features**\n",
    "numeric_features = ['driver_age', 'cumulative_points', 'avg_finish_position', 'avg_lap_time_ms',\n",
    "                    'avg_qualifying_position', 'driver_reliability', 'constructor_reliability']\n",
    "categorical_features = ['nationality_driver', 'name_constructor', 'country']"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a33bcdaf",
   "metadata": {},
   "source": [
    "## 4. Pre-Training on Older Data and Model Building"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "d987c4af",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **Split Data into Pre-1996, 1996-2018, Post-2018**\n",
    "\n",
    "# Pre-1996 Data\n",
    "pre_1996_mask = results['year'] <= 1996\n",
    "X_pre_train = X.loc[pre_1996_mask]\n",
    "y_pre_train = y.loc[pre_1996_mask]\n",
    "\n",
    "# 1997-2018 Data\n",
    "post_1996_mask = (results['year'] > 1996) & (results['year'] <= 2018)\n",
    "X_fine_tune = X.loc[post_1996_mask]\n",
    "y_fine_tune = y.loc[post_1996_mask]\n",
    "\n",
    "# Post-2018 Data\n",
    "post_2018_mask = results['year'] > 2018\n",
    "X_final_train = X.loc[post_2018_mask]\n",
    "y_final_train = y.loc[post_2018_mask]\n",
    "\n",
    "# **Define the Preprocessing Pipeline**\n",
    "numeric_transformer = StandardScaler()\n",
    "categorical_transformer = OneHotEncoder(handle_unknown='ignore')\n",
    "\n",
    "preprocessor = ColumnTransformer(\n",
    "    transformers=[\n",
    "        ('num', numeric_transformer, numeric_features),\n",
    "        ('cat', categorical_transformer, categorical_features)\n",
    "    ])\n",
    "\n",
    "# **Create the Pipeline**\n",
    "pipeline = Pipeline(steps=[('preprocessor', preprocessor),\n",
    "                           ('model', RandomForestRegressor(n_estimators=100, random_state=42))])\n",
    "\n",
    "# **Train the Pipeline on Pre-1996 Data**\n",
    "pipeline.fit(X_pre_train, y_pre_train)\n",
    "\n",
    "# **Fine-Tune the Pipeline with 1997-2018 Data**\n",
    "pipeline.fit(X_fine_tune, y_fine_tune)\n",
    "\n",
    "# **Train the Final Model with Post-2018 Data**\n",
    "pipeline.fit(X_final_train, y_final_train)\n",
    "\n",
    "# **Save the Pipeline**\n",
    "joblib.dump(pipeline, 'f1_race_predictor_pipeline.joblib')\n",
    "\n",
    "# **Extract the Preprocessor for Use in Real-Time Predictions**\n",
    "preprocessor = pipeline.named_steps['preprocessor']\n",
    "\n",
    "# **Save the Scaler and Encoder Separately (Optional)**\n",
    "scaler = preprocessor.named_transformers_['num']\n",
    "encoder = preprocessor.named_transformers_['cat']\n",
    "\n",
    "joblib.dump(scaler, 'scaler.joblib')\n",
    "joblib.dump(encoder, 'encoder.joblib')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dcbf5b49",
   "metadata": {},
   "source": [
    "## 5. Agent-Based Modeling"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "1dfc92a1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **Define Driver Agents**\n",
    "class DriverAgent:\n",
    "    def __init__(self, driverId, skill, aggression, reliability):\n",
    "        self.driverId = driverId\n",
    "        self.skill = skill\n",
    "        self.aggression = aggression\n",
    "        self.reliability = reliability\n",
    "        self.total_time_ms = 0\n",
    "        self.position = None\n",
    "        self.status = 'Running'\n",
    "\n",
    "# **Initialize Agents Based on Driver Performance**\n",
    "latest_year = results['year'].max()\n",
    "latest_raceId = results[results['year'] == latest_year]['raceId'].max()\n",
    "\n",
    "driver_list = results[results['raceId'] == latest_raceId]['driverId'].unique()\n",
    "\n",
    "driver_agents = []\n",
    "for driverId in driver_list:\n",
    "    # Get driver data\n",
    "    driver_data = results[results['driverId'] == driverId].sort_values('year', ascending=False).iloc[0]\n",
    "    # Skill: Inverse of average finishing position\n",
    "    skill = 1 / driver_data['avg_finish_position']\n",
    "    # Aggression: Random factor influenced by recent performance\n",
    "    aggression = np.random.uniform(0.5, 1.5)\n",
    "    # Reliability: From calculated reliability metric\n",
    "    reliability = driver_data['driver_reliability']\n",
    "    agent = DriverAgent(driverId, skill, aggression, reliability)\n",
    "    driver_agents.append(agent)\n",
    "\n",
    "# **Create a Dictionary for Driver Names**\n",
    "driver_names = drivers.set_index('driverId')[['forename', 'surname']].to_dict('index')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a3538fcd",
   "metadata": {},
   "source": [
    "## 6. Monte Carlo Simulation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "6cb8d365",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **Simulation Parameters**\n",
    "n_simulations = 10000\n",
    "n_laps = 50  # Placeholder for number of laps\n",
    "\n",
    "# **Simulate Races**\n",
    "simulation_results = []\n",
    "\n",
    "for sim in tqdm(range(n_simulations)):\n",
    "    # Deep copy of agents\n",
    "    agents = [DriverAgent(agent.driverId, agent.skill, agent.aggression, agent.reliability) for agent in driver_agents]\n",
    "    for lap in range(1, n_laps + 1):\n",
    "        for agent in agents:\n",
    "            # Check if driver is still running\n",
    "            if agent.status == 'Retired':\n",
    "                continue\n",
    "            # Simulate lap time based on skill and aggression\n",
    "            lap_time = np.random.normal(100000 / agent.skill, 1000)  # Placeholder values\n",
    "            lap_time *= agent.aggression\n",
    "            agent.total_time_ms += lap_time\n",
    "            # Simulate reliability (chance of retiring)\n",
    "            if random.random() > agent.reliability:\n",
    "                agent.status = 'Retired'\n",
    "    # Determine final positions\n",
    "    running_agents = [agent for agent in agents if agent.status == 'Running']\n",
    "    retired_agents = [agent for agent in agents if agent.status == 'Retired']\n",
    "    running_agents.sort(key=lambda x: x.total_time_ms)\n",
    "    for position, agent in enumerate(running_agents, start=1):\n",
    "        agent.position = position\n",
    "    # Assign positions to retired agents\n",
    "    for agent in retired_agents:\n",
    "        agent.position = 99  # Arbitrary high number for retired drivers\n",
    "    # Collect results\n",
    "    sim_result = {agent.driverId: agent.position for agent in agents}\n",
    "    simulation_results.append(sim_result)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd5234b6",
   "metadata": {},
   "source": [
    "## 7. Aggregate Simulation Results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "22abaf7c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **Aggregate Results into a DataFrame**\n",
    "sim_df = pd.DataFrame(simulation_results)\n",
    "\n",
    "# **Calculate Probabilities of Finishing Positions**\n",
    "position_probs = sim_df.apply(lambda x: x.value_counts(normalize=True)).fillna(0) * 100\n",
    "position_probs = position_probs.transpose()\n",
    "\n",
    "# **Prepare Data for Visualization**\n",
    "position_probs.reset_index(inplace=True)\n",
    "position_probs.rename(columns={'index': 'driverId'}, inplace=True)\n",
    "\n",
    "# **Merge with Driver Names**\n",
    "position_probs['driver_name'] = position_probs['driverId'].apply(lambda x: driver_names[x]['forename'] + ' ' + driver_names[x]['surname'])\n",
    "\n",
    "# **Sort by Expected Finishing Position**\n",
    "expected_positions = sim_df.mean().sort_values()\n",
    "position_probs['expected_position'] = position_probs['driverId'].map(expected_positions)\n",
    "position_probs.sort_values('expected_position', inplace=True)\n",
    "\n",
    "# **Display Probabilities**\n",
    "position_probs.fillna(0, inplace=True)\n",
    "position_probs.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1dfc92a1",
   "metadata": {},
   "source": [
    "## 8. Visualization"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "776ea2cb",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **Plot Probability Distribution of Finishing Positions**\n",
    "fig, ax = plt.subplots(figsize=(12, 8))\n",
    "positions = list(range(1, 21))  # Assuming max 20 positions\n",
    "\n",
    "for idx, row in position_probs.iterrows():\n",
    "    probabilities = [row.get(pos, 0) for pos in positions]\n",
    "    ax.plot(positions, probabilities, label=row['driver_name'])\n",
    "\n",
    "ax.set_xlabel('Finishing Position')\n",
    "ax.set_ylabel('Probability (%)')\n",
    "ax.set_title('Probability Distribution of Finishing Positions')\n",
    "ax.legend(loc='upper right', bbox_to_anchor=(1.3, 1.05))\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6cb8d365",
   "metadata": {},
   "source": [
    "### 8.1 Animated Line Plot of Lap-by-Lap Positions (For a Single Simulation)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "bd5234b6",
   "metadata": {},
   "outputs": [],
   "source": [
    "# **Simulate a Single Race for Visualization**\n",
    "agents = [DriverAgent(agent.driverId, agent.skill, agent.aggression, agent.reliability) for agent in driver_agents]\n",
    "lap_positions = []\n",
    "\n",
    "for lap in range(1, n_laps + 1):\n",
    "    for agent in agents:\n",
    "        # Check if driver is still running\n",
    "        if agent.status == 'Retired':\n",
    "            continue\n",
    "        # Simulate lap time based on skill and aggression\n",
    "        lap_time = np.random.normal(100000 / agent.skill, 1000)  # Placeholder values\n",
    "        lap_time *= agent.aggression\n",
    "        agent.total_time_ms += lap_time\n",
    "        # Simulate reliability (chance of retiring)\n",
    "        if random.random() > agent.reliability:\n",
    "            agent.status = 'Retired'\n",
    "    # Update positions\n",
    "    running_agents = [agent for agent in agents if agent.status == 'Running']\n",
    "    retired_agents = [agent for agent in agents if agent.status == 'Retired']\n",
    "    running_agents.sort(key=lambda x: x.total_time_ms)\n",
    "    for position, agent in enumerate(running_agents, start=1):\n",
    "        agent.position = position\n",
    "    for agent in retired_agents:\n",
    "        agent.position = 99  # Arbitrary high number\n",
    "    # Record positions\n",
    "    lap_positions.append({agent.driverId: agent.position for agent in agents})\n",
    "\n",
    "# **Prepare Data for Animation**\n",
    "position_df = pd.DataFrame(lap_positions)\n",
    "position_df['lap'] = range(1, n_laps + 1)\n",
    "position_df = pd.melt(position_df, id_vars=['lap'], var_name='driverId', value_name='position')\n",
    "\n",
    "# **Add Driver Names**\n",
    "position_df['driver_name'] = position_df['driverId'].apply(lambda x: driver_names[x]['forename'] + ' ' + driver_names[x]['surname'])\n",
    "\n",
    "# **Animate Lap-by-Lap Positions**\n",
    "# Get the list of drivers\n",
    "driver_names_list = position_df['driver_name'].unique()\n",
    "\n",
    "# Set up the figure and axes\n",
    "fig, ax = plt.subplots(figsize=(12, 8))\n",
    "\n",
    "# Set up the lines for each driver\n",
    "lines = {}\n",
    "for driver_name in driver_names_list:\n",
    "    line, = ax.plot([], [], label=driver_name)\n",
    "    lines[driver_name] = line\n",
    "\n",
    "# Set up the axes\n",
    "ax.set_xlim(1, n_laps)\n",
    "ax.set_ylim(20 + 1, 0)  # Reverse y-axis so position 1 is at the top\n",
    "ax.set_xlabel('Lap')\n",
    "ax.set_ylabel('Position')\n",
    "ax.set_title('Lap-by-Lap Driver Positions')\n",
    "ax.legend(loc='upper right', bbox_to_anchor=(1.15, 1.05))\n",
    "\n",
    "# Initialize the data for animation\n",
    "def init():\n",
    "    for line in lines.values():\n",
    "        line.set_data([], [])\n",
    "    return lines.values()\n",
    "\n",
    "# Update function for animation\n",
    "def update(frame):\n",
    "    current_lap = frame + 1\n",
    "    for driver_name in driver_names_list:\n",
    "        driver_data = position_df[position_df['driver_name'] == driver_name]\n",
    "        laps = driver_data[driver_data['lap'] <= current_lap]['lap']\n",
    "        positions = driver_data[driver_data['lap'] <= current_lap]['position']\n",
    "        lines[driver_name].set_data(laps, positions)\n",
    "    return lines.values()\n",
    "\n",
    "# Create the animation\n",
    "ani = FuncAnimation(fig, update, frames=n_laps, init_func=init, blit=False, interval=200, repeat=False)\n",
    "\n",
    "# Display the animation\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "776ea2cb",
   "metadata": {},
   "source": [
    "## 9. Conclusion\n",
    "\n",
    "In this notebook, we've:\n",
    "\n",
    "- **Integrated Historical Data**: Used historical race data to pre-train models and create driver agents.\n",
    "- **Calculated Reliability Metrics**: Used status codes to calculate driver and constructor reliability.\n",
    "- **Agent-Based Modeling**: Created driver agents with attributes influenced by historical performance and reliability.\n",
    "- **Monte Carlo Simulation**: Ran 10,000 simulations to predict possible race outcomes.\n",
    "- **Visualization**: Provided probability distributions of finishing positions and an animated lap-by-lap visualization.\n",
    "\n",
    "**Next Steps:**\n",
    "\n",
    "- **Incorporate Real Weather and Practice Session Data**: Replace placeholders with actual data when available.\n",
    "- **Refine Agent Attributes**: Continuously update agent attributes with the latest data.\n",
    "- **Expand Simulations**: Include more variables and uncertainties in simulations.\n",
    "- **Avoid Data Leakage**: Ensure models use only data available before the race.\n",
    "\n",
    "By simulating the race multiple times and analyzing the results, we can gain insights into the potential outcomes and the factors that might influence them, much like how a Formula 1 team would approach race strategy."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3.8",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
